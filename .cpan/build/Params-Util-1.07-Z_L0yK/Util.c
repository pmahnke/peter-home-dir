/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2210 from the
 * contents of Util.xs. Do not edit this file, edit Util.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Util.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* Changes in 5.7 series mean that now IOK is only set if scalar is
   precisely integer but in 5.6 and earlier we need to do a more
   complex test  */
#if PERL_VERSION <= 6
#define DD_is_integer(sv) (SvIOK(sv) && (SvIsUV(val) ? SvUV(sv) == SvNV(sv) : SvIV(sv) == SvNV(sv)))
#else
#define DD_is_integer(sv) SvIOK(sv)
#endif

static int
is_string0( SV *sv )
{
    return SvFLAGS(sv) & (SVf_OK & ~SVf_ROK);
}

static int
is_string( SV *sv )
{
    STRLEN len = 0;
    if( is_string0(sv) )
    {
        const char *pv = SvPV(sv, len);
    }
    return len;
}

static int
is_array( SV *sv )
{
    return SvROK(sv) && ( SVt_PVAV == SvTYPE(SvRV(sv) ) );
}

static int
is_hash( SV *sv )
{
    return SvROK(sv) && ( SVt_PVHV == SvTYPE(SvRV(sv) ) );
}

static int
is_like( SV *sv, const char *like )
{
    int likely = 0;
    if( sv_isobject( sv ) )
    {
        dSP;
        int count;

        ENTER;
        SAVETMPS;
        PUSHMARK(SP);
        XPUSHs( sv_2mortal( newSVsv( sv ) ) );
        XPUSHs( sv_2mortal( newSVpv( like, strlen(like) ) ) );
        PUTBACK;

        if( ( count = call_pv("overload::Method", G_SCALAR) ) )
        {
            I32 ax;
            SPAGAIN;

            SP -= count;
            ax = (SP - PL_stack_base) + 1;
            if( SvTRUE(ST(0)) )
                ++likely;
        }

        PUTBACK;
        FREETMPS;
        LEAVE;
    }

    return likely;
}

#line 88 "Util.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 140 "Util.c"

XS(XS_Params__Util__STRING); /* prototype to pass -Wmissing-prototypes */
XS(XS_Params__Util__STRING)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0);
#line 85 "Util.xs"
{
    if( SvMAGICAL(sv) )
        mg_get(sv);
    if( is_string( sv ) )
    {
        ST(0) = sv;
        XSRETURN(1);
    }
    XSRETURN_UNDEF;
}
#line 165 "Util.c"
    }
    XSRETURN(1);
}


XS(XS_Params__Util__NUMBER); /* prototype to pass -Wmissing-prototypes */
XS(XS_Params__Util__NUMBER)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0);
#line 101 "Util.xs"
{
    if( SvMAGICAL(sv) )
        mg_get(sv);
    if( ( SvIOK(sv) ) || ( SvNOK(sv) ) || ( is_string( sv ) && looks_like_number( sv ) ) )
    {
        ST(0) = sv;
        XSRETURN(1);
    }
    XSRETURN_UNDEF;
}
#line 194 "Util.c"
    }
    XSRETURN(1);
}


XS(XS_Params__Util__SCALAR0); /* prototype to pass -Wmissing-prototypes */
XS(XS_Params__Util__SCALAR0)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0);
#line 117 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( SvROK(ref) )
    {
        if( ( SvTYPE(SvRV(ref)) <= SVt_PVBM ) && !sv_isobject(ref) )
        {
            ST(0) = ref;
            XSRETURN(1);
        }
    }
    XSRETURN_UNDEF;
}
#line 226 "Util.c"
    }
    XSRETURN(1);
}


XS(XS_Params__Util__SCALAR); /* prototype to pass -Wmissing-prototypes */
XS(XS_Params__Util__SCALAR)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0);
#line 136 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( SvROK(ref) )
    {
        svtype tp = SvTYPE(SvRV(ref));
        if( ( SvTYPE(SvRV(ref)) <= SVt_PVBM ) && (!sv_isobject(ref)) && is_string( SvRV(ref) ) )
        {
            ST(0) = ref;
            XSRETURN(1);
        }
    }
    XSRETURN_UNDEF;
}
#line 259 "Util.c"
    }
    XSRETURN(1);
}


XS(XS_Params__Util__REGEX); /* prototype to pass -Wmissing-prototypes */
XS(XS_Params__Util__REGEX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0);
#line 156 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( SvROK(ref) )
    {
        svtype tp = SvTYPE(SvRV(ref));
#if PERL_VERSION >= 11
        if( ( SVt_REGEXP == tp ) )
#else
        if( ( SVt_PVMG == tp ) && sv_isobject(ref)
         && ( 0 == strncmp( "Regexp", sv_reftype(SvRV(ref),TRUE),
                            strlen("Regexp") ) ) )
#endif
        {
            ST(0) = ref;
            XSRETURN(1);
        }
    }
    XSRETURN_UNDEF;
}
#line 298 "Util.c"
    }
    XSRETURN(1);
}


XS(XS_Params__Util__ARRAY0); /* prototype to pass -Wmissing-prototypes */
XS(XS_Params__Util__ARRAY0)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0);
#line 182 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( is_array(ref) )
    {
        ST(0) = ref;
        XSRETURN(1);
    }

    XSRETURN_UNDEF;
}
#line 328 "Util.c"
    }
    XSRETURN(1);
}


XS(XS_Params__Util__ARRAY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Params__Util__ARRAY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0);
#line 199 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( is_array(ref) && ( av_len((AV *)(SvRV(ref))) >= 0 ) )
    {
        ST(0) = ref;
        XSRETURN(1);
    }
    XSRETURN_UNDEF;
}
#line 357 "Util.c"
    }
    XSRETURN(1);
}


XS(XS_Params__Util__ARRAYLIKE); /* prototype to pass -Wmissing-prototypes */
XS(XS_Params__Util__ARRAYLIKE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0);
#line 215 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( SvROK(ref) )
    {
        if( is_array(ref) || is_like( ref, "@{}" ) )
        {
            ST(0) = ref;
            XSRETURN(1);
        }
    }

    XSRETURN_UNDEF;
}
#line 390 "Util.c"
    }
    XSRETURN(1);
}


XS(XS_Params__Util__HASH0); /* prototype to pass -Wmissing-prototypes */
XS(XS_Params__Util__HASH0)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0);
#line 235 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( is_hash(ref) )
    {
        ST(0) = ref;
        XSRETURN(1);
    }

    XSRETURN_UNDEF;
}
#line 420 "Util.c"
    }
    XSRETURN(1);
}


XS(XS_Params__Util__HASH); /* prototype to pass -Wmissing-prototypes */
XS(XS_Params__Util__HASH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0);
#line 252 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( is_hash(ref) && ( HvKEYS(SvRV(ref)) >= 1 ) )
    {
        ST(0) = ref;
        XSRETURN(1);
    }

    XSRETURN_UNDEF;
}
#line 450 "Util.c"
    }
    XSRETURN(1);
}


XS(XS_Params__Util__HASHLIKE); /* prototype to pass -Wmissing-prototypes */
XS(XS_Params__Util__HASHLIKE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0);
#line 269 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( SvROK(ref) )
    {
        if( is_hash(ref) || is_like( ref, "%{}" ) )
        {
            ST(0) = ref;
            XSRETURN(1);
        }
    }

    XSRETURN_UNDEF;
}
#line 483 "Util.c"
    }
    XSRETURN(1);
}


XS(XS_Params__Util__CODE); /* prototype to pass -Wmissing-prototypes */
XS(XS_Params__Util__CODE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0);
#line 289 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( SvROK(ref) )
    {
        if( SVt_PVCV == SvTYPE(SvRV(ref)) )
        {
            ST(0) = ref;
            XSRETURN(1);
        }
    }
    XSRETURN_UNDEF;
}
#line 515 "Util.c"
    }
    XSRETURN(1);
}


XS(XS_Params__Util__CODELIKE); /* prototype to pass -Wmissing-prototypes */
XS(XS_Params__Util__CODELIKE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0);
#line 308 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( SvROK(ref) )
    {
        if( ( SVt_PVCV == SvTYPE(SvRV(ref)) ) || ( is_like(ref, "&{}" ) ) )
        {
            ST(0) = ref;
            XSRETURN(1);
        }
    }
    XSRETURN_UNDEF;
}
#line 547 "Util.c"
    }
    XSRETURN(1);
}


XS(XS_Params__Util__INSTANCE); /* prototype to pass -Wmissing-prototypes */
XS(XS_Params__Util__INSTANCE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "ref, type");
    {
	SV *	ref = ST(0);
	char *	type = (char *)SvPV_nolen(ST(1));
#line 328 "Util.xs"
{
    STRLEN len;
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( SvROK(ref) && type && ( ( len = strlen(type) ) > 0 ) )
    {
        if( sv_isobject(ref) )
        {
            I32 isa_type = 0;
            int count;

            ENTER;
            SAVETMPS;
            PUSHMARK(SP);
            XPUSHs( sv_2mortal( newSVsv( ref ) ) );
            XPUSHs( sv_2mortal( newSVpv( type, len ) ) );
            PUTBACK;

            if( ( count = call_method("isa", G_SCALAR) ) )
            {
                I32 oldax = ax;
                SPAGAIN;
                SP -= count;
                ax = (SP - PL_stack_base) + 1;
                isa_type = SvTRUE(ST(0));
                ax = oldax;
            }

            PUTBACK;
            FREETMPS;
            LEAVE;

            if( isa_type )
            {
                ST(0) = ref;
                XSRETURN(1);
            }
        }
    }
    XSRETURN_UNDEF;
}
#line 608 "Util.c"
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Params__Util); /* prototype to pass -Wmissing-prototypes */
XS(boot_Params__Util)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK ;

        (void)newXSproto_portable("Params::Util::_STRING", XS_Params__Util__STRING, file, "$");
        (void)newXSproto_portable("Params::Util::_NUMBER", XS_Params__Util__NUMBER, file, "$");
        (void)newXSproto_portable("Params::Util::_SCALAR0", XS_Params__Util__SCALAR0, file, "$");
        (void)newXSproto_portable("Params::Util::_SCALAR", XS_Params__Util__SCALAR, file, "$");
        (void)newXSproto_portable("Params::Util::_REGEX", XS_Params__Util__REGEX, file, "$");
        (void)newXSproto_portable("Params::Util::_ARRAY0", XS_Params__Util__ARRAY0, file, "$");
        (void)newXSproto_portable("Params::Util::_ARRAY", XS_Params__Util__ARRAY, file, "$");
        (void)newXSproto_portable("Params::Util::_ARRAYLIKE", XS_Params__Util__ARRAYLIKE, file, "$");
        (void)newXSproto_portable("Params::Util::_HASH0", XS_Params__Util__HASH0, file, "$");
        (void)newXSproto_portable("Params::Util::_HASH", XS_Params__Util__HASH, file, "$");
        (void)newXSproto_portable("Params::Util::_HASHLIKE", XS_Params__Util__HASHLIKE, file, "$");
        (void)newXSproto_portable("Params::Util::_CODE", XS_Params__Util__CODE, file, "$");
        (void)newXSproto_portable("Params::Util::_CODELIKE", XS_Params__Util__CODELIKE, file, "$");
        (void)newXSproto_portable("Params::Util::_INSTANCE", XS_Params__Util__INSTANCE, file, "$$");
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

